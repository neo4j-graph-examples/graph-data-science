<style type="text/css" media="screen">
/*
.nodes-image {
	margin:-100;
}
*/	
@import url("//maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css");

.imageblock .content img, .image img {max-width: 900px;max-height: 300px;}
.deck h3, .deck h4 {display: block !important;margin-bottom:8px;margin-top:5px;}
.listingblock {margin:8px;}
.pull-bottom {position:relative;bottom:1em;}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note:before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip:before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning:before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution:before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important:before{content:"\f06a";color:#bf0000}
.admonitionblock.note.speaker { display:none; }
</style>
<style type="text/css" media="screen">
/* #editor.maximize-editor .CodeMirror-code { font-size:24px; line-height:26px; } */
</style>
<article class="guide" ng-controller="AdLibDataController">
  <carousel class="deck container-fluid">
    <!--slide class="row-fluid">
      <div class="col-sm-3">
        <h3>Graph Algorithms</h3>
        <p class="lead">Information</p>
			<!dl>
				
				
				
				
				
			</dl>
		</div>
      <div class="col-sm-9">
        <figure>
          <img style="width:300px" src=""/>
        </figure>
      </div>
    </slide-->
    


   <h4>Graph Algorithms</h4>
   


<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Neo4j Graph Data Science</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>The Neo4j Graph Data Science (GDS) library contains a set of graph algorithms, exposed through Cypher procedures.
Graph algorithms provide insights into the graph structure and elements, for example, by computing centrality and similarity scores, and detecting communities.
The GDS library is divided into three tiers of maturity: product, beta and alpha.</p>
</div>
<div class="paragraph">
<p>This guide follows the ordinary workflow for running the product tier algorithms: PageRank, Label Propagation, Weakly Connected Components, Louvain, and Node Similarity.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Estimate memory usage for your graph and the algorithm you want to run.</p>
</li>
<li>
<p>Create a graph and manage created graphs.</p>
</li>
<li>
<p>Configure the algorithm to suit your needs and run it in one of the supported modes: stream, write, and stats.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For more details, see <a href="https://neo4j.com/docs/graph-algorithms/current/" target="_blank">the documentation</a>.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>The example dataset</h3>
    <br/>
    <div>
      <div class="imageblock" style="float: right;">
<div class="content">
<img src="https://upload.wikimedia.org/wikipedia/en/2/24/AStormOfSwords.jpg" alt="AStormOfSwords" width="150">
</div>
</div>
<div class="paragraph">
<p>The example dataset used to demonstrate the GDS library is based on the Game of Thrones fantasy saga.
You may recognize it from the blogs, events, and sandbox.
However, both data and queries are different enough from previous installments that it merits your attention.
&#160;<br>
&#160;<br>
&#160;<br></p>
</div>



   <h4>Attribution</h4>
   <div class="paragraph">
<p>The dataset is partly based on the following works:</p>
</div>
<div class="paragraph">
<p><em><a href="https://networkofthrones.wordpress.com/" target="_blank">Network of Thrones, A Song of Math and Westeros</a>, research by Dr. Andrew Beveridge.</em><br>
<em><a href="https://www.macalester.edu/~abeverid/index.html" target="_blank">A. Beveridge and J. Shan, "Network of Thrones," Math Horizons Magazine , Vol. 23, No. 4 (2016), pp. 18-22</a></em><br>
<em><a href="https://www.kaggle.com/mylesoneill/game-of-thrones">Game of Thrones, Explore deaths and battles from this fantasy world</a>, by Myles O&#8217;Neill, <a href="https://www.kaggle.com/" target="_blank">https://www.kaggle.com/</a></em><br>
<em><a href="https://github.com/tomasonjo/neo4j-game-of-thrones" target="_blank">Game of Thrones</a>, by Tomaz Bratanic, GitHub repository.</em></p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Graph of character interactions.. and more</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>The graph contains <code>:Person</code> nodes, representing the characters, and <code>:INTERACTS</code> relationships, representing the characters' interactions.
An interaction occurs each time two characters' names (or nicknames) <strong>appear within 15 words of one another</strong> in the book text.
For more information about the data extraction process, see <em><a href="https://networkofthrones.wordpress.com/from-book-to-network/" target="_blank">Network of Thrones, A Song of Math and Westeros</a>, research by Dr. Andrew Beveridge.</em></p>
</div>
<div class="paragraph">
<p>The <code>(:Person)-[:INTERACTS]&#8594;(:Person)</code> graph is enriched with data on houses, battles, commanders, kings, knights, regions, locations, and deaths.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Data visualization</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>Let&#8217;s briefly explore the dataset before running some algorithms.</p>
</div>
<div class="paragraph">
<p>Run the following query to visualize the schema of your graph:</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL db.schema.visualization()<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>:Dead</code>, <code>:King</code>, and <code>:Knight</code> labels all appear on <code>:Person</code> nodes.
You may find it useful to remove them from the visualization to make it easier to inspect.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Summary statistics</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>Calculate some simple statistics to see how data is distributed.
For example, find the minimum, maximum, average, and standard deviation of the number of interactions per character:</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->MATCH (c:Person)-[:INTERACTS]-&gt;()
WITH c, count(*) AS num
RETURN min(num) AS min, max(num) AS max, avg(num) AS avg_interactions, stdev(num) AS stdev<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>Calculate the same grouped by book:</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->MATCH (c:Person)-[r:INTERACTS]-&gt;()
WITH r.book as book, c, count(*) AS num
RETURN book, min(num) AS min, max(num) AS max, avg(num) AS avg_interactions, stdev(num) AS stdev
ORDER BY book<!--/code--></pre>
</div>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Estimate memory usage: why?</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>Now that you have data and know something about its shape, you need to estimate the memory usage of your graph and algorithm(s), and to configure your Neo4j Server with a much larger heap size than for a transactional deployment.
Why?</p>
</div>
<div class="paragraph">
<p>Because, the graph algorithms run on an in-memory, heap-allocated projection of the Neo4j graph, which resides outside the main database.
This means that before you execute an algorithm, you must create (explicitly or implicitly) a projection of your graph in memory.</p>
</div>
<div class="paragraph">
<p>However, creating graphs and running algorithms on them can have a significant memory footprint.</p>
</div>
<div class="paragraph">
<p>Therefore, a good habit is always to estimate the amount of RAM you need and configure a large heap size before running a heavy memory workload.</p>
</div>
<div class="paragraph">
<p>In the following three chapters, you will be able to exercise memory estimation and explore its results.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Memory estimation: graphs</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>The GDS library offers a set of procedures that can help you estimate the memory needed to create a graph and run algorithms.</p>
</div>
<div class="paragraph">
<p>To estimate the required memory for a subset of your graph, for example, the <code>Person</code> nodes and <code>INTERACTS</code> relationships, call the following procedure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.create.estimate('Person', 'INTERACTS') YIELD nodeCount, relationshipCount, requiredMemory<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>The result shows that the example graph is small.
So, you can create your projected graph and name it, for example, <code>got-interactions</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.create('got-interactions', 'Person', 'INTERACTS')<!--/code--></pre>
</div>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Estimate memory usage: algorithms</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>To estimate the memory needed to execute an algorithm on your <code>got-interactions</code> graph, for example, Page Rank, call the following procedure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.pageRank.stream.estimate('got-interactions') YIELD requiredMemory<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>This estimation considers only the algorithm execution, as the graph is already in-memory.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Estimate memory usage: details</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>If you want to look at the full details of the memory estimation, remove the <code>YIELD</code> clause.
The procedure returns a tree view and a map view of all the "components" with their memory estimates.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.pageRank.stream.estimate('got-interactions')<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>As you see, the more detailed views contain estimates on the individual compute steps and the result data structures.</p>
</div>
<div class="paragraph">
<p>You can also estimate the memory usage for graph creation and algorithm execution at the same time by using the so-called <em>implicit graph creation</em>.
This way, the configuration for the graph creation is inlined within the algorithm procedure call.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.pageRank.stream.estimate({nodeProjection: 'Person', relationshipProjection: 'INTERACTS'})<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>The result shows an increased memory estimate, explained by the memory consumed by the graph creation.</p>
</div>
<div class="paragraph">
<p>Now, you can filter the result to the top level components: graph and algorithm.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.pageRank.stream.estimate({
  nodeProjection: 'Person',
  relationshipProjection: 'INTERACTS'
}) YIELD mapView
UNWIND [ x IN mapView.components | [x.name, x.memoryUsage] ] AS component
RETURN component[0] AS name, component[1] AS size<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>For more details, see <em><a href="https://neo4j.com/docs/graph-algorithms/current/projected-graph-model/memory-requirements/" target="_blank">the Memory requirements chapter in the Graph Algorithms User Guide</a></em>.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Memory estimation: cleanup</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>If you do not want to use the projected graph anymore, a good practice is to release it from the memory.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.drop('got-interactions');<!--/code--></pre>
</div>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Graph creation</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>The first stage of execution in GDS is always graph creation, but what does this mean?</p>
</div>
<div class="paragraph">
<p>To enable fast caching of the graph topology, containing only the relevant nodes, relationships, and weights, the GDS library operates on in-memory graphs that are created as projections of the Neo4j stored graph.</p>
</div>
<div class="paragraph">
<p>These projections may change the nature of the graph elements by any of the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Subgraphing</p>
</li>
<li>
<p>Renaming relationship types or node labels</p>
</li>
<li>
<p>Merging several relationship types or node labels</p>
</li>
<li>
<p>Altering relationship direction</p>
</li>
<li>
<p>Aggregating parallel relationships and their properties</p>
</li>
<li>
<p>Deriving relationships from larger patterns</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>There are two ways of creating graphs – <em>explicit</em> and <em>implicit</em>.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Graph catalog</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>The typical workflow is to create the projected graph <em>explicitly</em> by giving it a name and storing it in the <em>graph catalog</em>.
This allows you to operate on the graph multiple times.</p>
</div>
<div class="paragraph">
<p>In the <em>Memory estimation</em> chapters, you calculated the memory needed for creating a small graph of interactions, called <code>got-interactions</code>.
If you have removed it from the memory, you can create it again.
Because each <code>INTERACTS</code> relationship is symmetric, you can even ignore its direction by creating your graph with an <code>UNDIRECTED</code> orientation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.create('got-interactions', 'Person', {
  INTERACTS: {
    orientation: 'UNDIRECTED'
  }
})<!--/code--></pre>
</div>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Graph catalog: standard creation and Cypher projection</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>The GDS library supports two approaches for loading projected graphs - <strong>standard creation</strong> (<code>gds.graph.create()</code>) and <strong>Cypher projection</strong> (<code>gds.graph.create.cypher()</code>).</p>
</div>
<div class="paragraph">
<p>In the <strong>standard creation</strong> approach, which you used to create your graph, you specify node labels and relationship types and project them onto the in-memory graph as labels and relationship types with new names.
You can further specify properties for each node label and relationship type.
For some use cases, this approach might be sufficient.
However, it is not possible to take only some nodes with a given label or only some relationships of a given type.
One way to work around it is by adding additional labels that define the desired subset of nodes that you want to project.</p>
</div>
<div class="paragraph">
<p>In the <strong>Cypher projection</strong> approach, you use Cypher queries to project nodes and relationships onto the in-memory graph.
Instead of specifying labels and relationship types, you define node-statements and relationship-statements.
In this way, you can leverage the expressivity of the Cypher language and describe your graph in a more sophisticated way.</p>
</div>
<div class="paragraph">
<p>It is important to note that the standard creation is orders of magnitude faster than the Cypher projection.
When designing a use case with Cypher projection at a production scale, make sure to measure the performance in advance.</p>
</div>
<div class="paragraph">
<p>Now, let’s try the Cypher projection and load the same graph with a new name, for example, <code>got-interactions-cypher</code>.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Graph catalog: Cypher projection</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>You run two queries: one for the nodes and one for the relationships.
You can also remove the parallel relationships between the pairs of nodes by adding an <code>aggregation</code> key for the property <code>weight</code> in the <code>relationshipProperties</code> specification.
The <code>relationshipProperties</code> configuration maps a returned property to property names used internally.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.create.cypher(
  'got-interactions-cypher',
  'MATCH (n:Person) RETURN id(n) AS id',
  'MATCH (s:Person)-[i:INTERACTS]-&gt;(t:Person) RETURN id(s) AS source, id(t) AS target, i.weight AS weight',
  {
    relationshipProperties: {
      weight: {
        property: 'weight',
        aggregation: 'SINGLE'
    }
  }
})<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>The first query returns the node IDs; the second one returns the source and target IDs of the relationships; and the <code>aggregation</code> key modifies the property values according to the specified aggregation.
Here, you can use any pair of Cypher queries as long as they return the expected columns and field types.<br>
To keep all relationships, use <code>aggregation: 'NONE'</code>.
To retain one of the relationships (arbitrary selected), use <code>aggregation: 'SKIP'</code>.
More details about the deduplication strategies, you can find <em><a href="https://neo4j.com/docs/graph-algorithms/current/projected-graph-model/cypher-projection/#cypher-projection-relationship-deduplication" target="_blank">here</a></em>.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Graph catalog: Cypher projection of virtual relationships</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>Another interesting feature of the Cypher graph projection is that it allows you to represent complex patterns by computing relationships that do not exist in the Neo4j stored graph.
This is especially useful when the algorithm you want to run supports only mono-partite graphs.<br>
For example, you can use the following query to create a graph with <code>Person</code> nodes connected with an (untyped) relationship if they belong to the same house.
The projected relationship does not exist in the stored graph.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.create.cypher(
  'same-house-graph',
  'MATCH (n:Person) RETURN id(n) AS id',
  'MATCH (p1:Person)-[:BELONGS_TO]-(:House)-[:BELONGS_TO]-(p2:Person) RETURN id(p1) AS source, id(p2) AS target'
)<!--/code--></pre>
</div>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Graph catalog: listing</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>After you create your projected graph, you can try several useful queries to manage it.</p>
</div>
<div class="paragraph">
<p>You can list all information about it by using following procedure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.list('got-interactions-cypher')<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>You can list the graphs you have loaded so far by using following procedure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.list()<!--/code--></pre>
</div>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Graph catalog: existence</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>You can check if a graph exists by using the following procedure:</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.exists('got-interactions')<!--/code--></pre>
</div>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Graph catalog: removal</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>You can free up memory space by dropping some of the created graphs from the catalog:</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.drop('got-interactions-cypher');<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p><strong>TIP:</strong> It is a good practice to remove the unused graphs, yours and of the previous users, from the memory.</p>
</div>
<div class="paragraph">
<p><strong>NOTE:</strong> Multiple users running algorithms at the same time is not supported.</p>
</div>
<div class="paragraph">
<p>Now you are ready to run some actual algorithms.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Getting started with algorithms</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>With Neo4j, you can run algorithms on explicitly and implicitly created graphs.<br>
In this tutorial, we will show you how to get the most out of the following algorithms:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Page Rank</p>
</li>
<li>
<p>Label Propagation</p>
</li>
<li>
<p>Weakly Connected Components (WCC)</p>
</li>
<li>
<p>Louvain</p>
</li>
<li>
<p>Node Similarity</p>
</li>
</ul>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Algorithm syntax: explicit graphs</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>Running algorithms on explicitly created graphs allows you to operate on a graph multiple times.
To do this, refer to the graph by its name,  as it is stored in the graph catalog.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding"><!--code-->CALL gds.&lt;algo-name&gt;.&lt;mode&gt;(
  graphName: String,
  configuration: Map
)<!--/code--></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>&lt;algo-name&gt;</code> is the algorithm name.</p>
</li>
<li>
<p><code>&lt;mode&gt;</code> is the algorithm execution mode.
The supported modes are:</p>
<div class="ulist">
<ul>
<li>
<p><code>write</code>: writes results to the Neo4j database and returns a summary of the results.</p>
</li>
<li>
<p><code>stats</code>: same as <code>write</code> but does not write to the Neo4j database.</p>
</li>
<li>
<p><code>stream</code>: streams results back to the user.</p>
</li>
</ul>
</div>
</li>
<li>
<p>The <code>graphName</code> parameter value is the name of the graph from the graph catalog.</p>
</li>
<li>
<p>The <code>configuration</code> parameter value is the algorithm-specific configuration.</p>
</li>
</ul>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Algorithm syntax: implicit graphs</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>The implicit variant does not access the graph catalog.
If you want to run an algorithm on such a graph, you configure the graph creation within the algorithm configuration map.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding"><!--code-->CALL gds.&lt;algo-name&gt;.&lt;mode&gt;(
  configuration: Map
)<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>After the algorithm execution finishes, the graph is released from the memory.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Page Rank</h3>
    <br/>
    <div>
      <div class="imageblock" style="float: right;">
<div class="content">
<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/fb/PageRanks-Example.svg/758px-PageRanks-Example.svg.png" alt="758px PageRanks Example.svg" width="300">
</div>
</div>
<div class="paragraph">
<p>Page Rank is an algorithm that measures the transitive influence and connectivity of nodes to find the most <strong>influential</strong> nodes in a graph.<br>
It computes an influence value for each node, called a <em>score</em>.
As a result, the score of a node is a certain weighted average of the scores of its direct neighbors.</p>
</div>
<div class="paragraph">
<p><strong>How Page Rank works</strong></p>
</div>
<div class="paragraph">
<p>PageRank is an <em>iterative</em> algorithm.
In each iteration, every node propagates its score evenly divided to its neighbours.<br>
The algorithm runs for a configurable maximum number of iterations (default is 20), or until the node scores converge.
That is, when the maximum change in node score between two sequential iterations is smaller than the configured <code>tolerance</code> value.
For more information about tolerance, see <em><a href="https://neo4j.com/docs/graph-data-science/preview/algorithms/page-rank/#algorithms-pagerank-syntax" target="_blank">the documentation</a></em>.</p>
</div>
<div class="paragraph">
<p>In the following chapters, you will see how Page Rank identifies the most important nodes.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Page Rank: stream mode</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>Let&#8217;s find out who is influential in the graph by running Page Rank.</p>
</div>
<div class="paragraph">
<p>First, you run a basic Page Rank call in <code>stream</code> mode.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.pageRank.stream('got-interactions') YIELD nodeId, score
RETURN gds.util.asNode(nodeId).name AS name, score
ORDER BY score DESC LIMIT 10<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>Then, you compare the Page Rank of each <code>Person</code> node with the number of interactions for that node.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.pageRank.stream('got-interactions') YIELD nodeId, score AS pageRank
WITH gds.util.asNode(nodeId) AS n, pageRank
MATCH (n)-[i:INTERACTS]-()
RETURN n.name AS name, pageRank, count(i) AS interactions
ORDER BY pageRank DESC LIMIT 10<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>The result shows that not always the most talkative characters have the highest rank.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Page Rank: write mode</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>Now that you have the results from your Page Rank query, you write them back to Neo4j and use them for further queries.<br>
You specify the name of the property to which the algorithm will write using the <code>writeProperty</code> key in the config map passed to the procedure.</p>
</div>
<div class="paragraph">
<p>Note that the writing is done in Neo4j, not in the graph <code>got-interactions</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.pageRank.write('got-interactions', {writeProperty: 'pageRank'})<!--/code--></pre>
</div>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Page Rank: rank per book</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>Along with the generic <code>INTERACTS</code> relationships, you also have <code>INTERACTS_1</code>, <code>INTERACTS_2</code>, etc., for the different books.
Let&#8217;s load a graph for the interactions in book 1 and compute and write the Page Rank scores.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.create(
  'got-interactions-1',
  'Person',
  {
    INTERACTS_1: {
      orientation: 'UNDIRECTED'
    }
  }
);<!--/code--></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.pageRank.write(
  'got-interactions-1',
  {
    writeProperty: 'pageRank-1'
  }
)<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>It is generally a good idea to explicitly create the graph before executing an algorithm.
However, if you do not think that you will operate on this graph in the future, you can load it implicitly as part of the algorithm execution.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.pageRank.write({
  nodeProjection: 'Person',
  relationshipProjection: {
    INTERACTS_1: {
      orientation: 'UNDIRECTED'
    }
  },
  writeProperty: 'pageRank-1'
})<!--/code--></pre>
</div>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Page Rank: exercise</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>Let&#8217;s see what you have learned so far.</p>
</div>
<div class="paragraph">
<p>Try to calculate the Page Rank of the other books in the series and store the results in the database.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Write queries that call <code>algo.pageRank</code> for the <code>INTERACTS_2</code>, <code>INTERACTS_3</code>, <code>INTERACTS_4</code>, and <code>INTERACTS_5</code> relationship types.
You can load a graph for each relationship type explicitly, or use the shorthand.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Then, try to write queries to answer the following questions:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Which character has the biggest increase in influence from book 1 to 5?</p>
</li>
<li>
<p>Which character has the biggest decrease?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Bonus task</strong></p>
</div>
<div class="ulist">
<ul>
<li>
<p>Use a Cypher projection to create a graph of <code>House</code>s that fought in the same <code>Battle</code>s and run Page Rank.</p>
</li>
<li>
<p>Does the result change if you weight Page Rank with the number of shared <code>Battle</code>s?</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can find the solution on the next slide.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Page Rank: exercise answer</h3>
    <br/>
    <div>
      <div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.create.cypher(
  'house-battles',
  'MATCH (h:House) RETURN id(h) AS id',
  'MATCH (h1:House)--&gt;(b:Battle)&lt;--(h2:House) RETURN id(h1) AS source, id(h2) AS target, count(b) AS weight',
  {
    relationshipProperties: 'weight'
  }
)<!--/code--></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.pageRank.stream(
  'house-battles',
  {
    relationshipWeightProperty: 'weight'
  }
)
YIELD nodeId, score
RETURN gds.util.asNode(nodeId).name AS name, score
ORDER BY score DESC<!--/code--></pre>
</div>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Label Propagation</h3>
    <br/>
    <div>
      <div class="imageblock" style="float: right;">
<div class="content">
<img src="https://s3.amazonaws.com/dev.assets.neo4j.com/wp-content/uploads/20190226091707/label-propagation-graph-algorithm-1.png" alt="label propagation graph algorithm 1" width="300">
</div>
</div>
<div class="paragraph">
<p>Label Propagation (LPA) is a fast algorithm for finding communities in a graph.
It propagates labels throughout the graph and forms communities of nodes based on their influence.</p>
</div>
<div class="paragraph">
<p><strong>How Label Propagation works</strong></p>
</div>
<div class="paragraph">
<p>LPA is an <em>iterative</em> algorithm.
First, it assigns a unique community label to each node.<br>
In each iteration, the algorithm changes this label to the most common one among its neighbors.
Densely connected nodes quickly broadcast their labels across the graph.<br>
At the end of the propagation, only a few labels remain.<br>
Nodes that have the same community label at convergence are considered from the same community.
The algorithm runs for a configurable maximum number of iterations, or until it converges.</p>
</div>
<div class="paragraph">
<p>For more details, see <em><a href="https://neo4j.com/docs/graph-data-science/1.0-preview/algorithms/label-propagation/" target="_blank">the documentation</a></em>.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Label Propagation: example</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>Let&#8217;s run Label Propagation to find the five largest communities of people interacting with each other.<br>
For flexibility, in this example, you can create the graph directly in the algorithm call.<br>
The weight property on the relationship represents the number of interactions between two people.
In LPA, the weight is used to determine the influence of neighboring nodes when voting on community assignment.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.create(
  'got-interactions-weighted',
  'Person',
  {
    INTERACTS: {
      orientation: 'UNDIRECTED',
      properties: 'weight'
    }
  }
)<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>Let&#8217;s now run LPA with just one iteration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.labelPropagation.stream(
  'got-interactions-weighted',
  {
    relationshipWeightProperty: 'weight',
    maxIterations: 1
  }
) YIELD nodeId, communityId
RETURN communityId, count(nodeId) AS size
ORDER BY size DESC
LIMIT 5<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>You can see that the nodes are assigned to initial communities - 2166	nodes to 1476 communities.<br>
However, the algorithm needs multiple iterations to achieve a stable result.
So, you run the same procedure with two iterations and see how the results change.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.labelPropagation.stream(
  'got-interactions-weighted',
  {
    relationshipWeightProperty: 'weight',
    maxIterations: 2
  }
) YIELD nodeId, communityId
RETURN communityId, count(nodeId) AS size
ORDER BY size DESC
LIMIT 5<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>Usually, label propagation requires more than a few iterations to converge on a stable result.
The number of the required iterations depends on the graph structure&#8201;&#8212;&#8201;you should experiment.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Label Propagation: seeding</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>Label Propagation can be seeded with an initial community label from a pre-existing node property.
This allows you to compute communities incrementally.<br>
Let&#8217;s write the results after the first iteration back to the source graph, under the write property name <code>community</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.labelPropagation.write(
  'got-interactions-weighted',
  {
    relationshipWeightProperty: 'weight',
    maxIterations: 1,
    writeProperty: 'community'
  }
)<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>You can now use the <code>community</code> property as a seed property for the second iteration.
The results should be the same as the previous run with two iterations.<br>
Seeding is particularly useful when the source graph grows and you want to compute communities incrementally, without starting again from scratch.
Since 'got-interactions-weighted' does not contain the 'community' property, you must create a new graph that does.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.create(
  'got-interactions-seeded',
  {
    Person: {
      properties: 'community'
    }
  },
  {
    INTERACTS: {
      orientation: 'UNDIRECTED',
      properties: 'weight'
    }
  }
)<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>And then, you can use the <code>seed</code> configuration key to specify the property from which you want to seed community IDs.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.labelPropagation.stream(
  'got-interactions-seeded',
  {
    relationshipWeightProperty: 'weight',
    maxIterations: 1,
    seedProperty: 'community'
  }
) YIELD nodeId, communityId
RETURN communityId, count(nodeId) AS size
ORDER BY size DESC
LIMIT 5<!--/code--></pre>
</div>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Label Propagation: exercise</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>Now that you understand the basics of LPA, let&#8217;s experiment a little.</p>
</div>
<div class="ulist">
<ul>
<li>
<p>How many iterations does it take for LPA to converge on a stable number of communities? How many communities do you end up with?</p>
</li>
<li>
<p>What happens when you run LPA for 1,000 maxIterations? (<em>hint: try using YIELD ranIterations</em>)</p>
</li>
<li>
<p>What happens if you run LPA without weights? Do you find the same communities?</p>
</li>
<li>
<p><strong>Bonus task</strong>: What if you use house affiliations as seeds for communities? How would you use Cypher to create the initial seeds? Run the algorithm with the new seeds. Do you find a different set of communities?</p>
</li>
</ul>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Label Propagation: cleanup</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>Now that you are done with Label Propagation, you can remove the graphs from the catalog.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.drop('got-interactions-weighted');<!--/code--></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.drop('got-interactions-seeded');<!--/code--></pre>
</div>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Weakly Connected Components</h3>
    <br/>
    <div>
      <div class="imageblock" style="float: right;">
<div class="content">
<img src="https://s3.amazonaws.com/dev.assets.neo4j.com/wp-content/uploads/20190222092528/union-find-graph-algorithm-visualization-3.png" alt="union find graph algorithm visualization 3" width="350">
</div>
</div>
<div class="paragraph">
<p>The Weakly Connected Components algorithm (previously known as Union Find) finds sets of connected nodes in an <em>undirected</em> graph, where each node is reachable from any other node in the same set.
It is called <em>weakly</em> because it relies on the relationship between two nodes regardless of its direction, wherefore the graph is treated as <em>undirected</em>.<br>
This algorithm is useful for identifying disjoint subgraphs, when pre-processing graphs, or for disambiguation purposes.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s start with a simple example that shows how to run the algorithm and stream the results.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Weakly Connected Components: example</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>You can re-use the <code>got-interactions</code> graph and run the algorithm to compute components.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.wcc.stream('got-interactions')
YIELD nodeId, componentId
RETURN componentId as component, count(nodeId) AS size
ORDER BY size DESC<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>The result is one large component containing 795 characters and many isolated characters.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Weakly Connected Components: connected components</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>Let&#8217;s use a Cypher projection to build a new graph named <code>got-culture-interactions-cypher</code>.
It will contain people that belong to the same culture.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.create.cypher(
  'got-culture-interactions-cypher',
  'MATCH (n:Person) RETURN id(n) AS id',
  'MATCH (p1:Person)-[:MEMBER_OF_CULTURE]-&gt;(c:Culture)&lt;-[:MEMBER_OF_CULTURE]-(p2:Person) RETURN id(p1) AS source, id(p2) AS target'
)<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>Now, run the algorithm to compute components.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.wcc.stream('got-culture-interactions-cypher')
YIELD nodeId, componentId
RETURN componentId as component, count(nodeId) AS size ORDER BY size DESC<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>The result is components with different sizes.</p>
</div>
<div class="paragraph">
<p>Reviewing the results, which cultures are represented by the five largest components?</p>
</div>
<div class="paragraph">
<p>Can you modify the query to write the components back to the database?
Add the property <code>wcc_partition</code> to your <code>:Person</code> nodes.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Weakly Connected Components: thresholds</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>You can also use some additional configuration options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>threshold</code> for connectivity (used along with <code>relationshipWeightProperty</code>)</p>
</li>
<li>
<p><code>seedProperty</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p><strong>Threshold</strong></p>
</div>
<div class="paragraph">
<p>If the <code>threshold</code> option is specified, the <code>relationshipWeightProperty</code> option must also be present.
In this case, relationships whose weight is below the given threshold will not be used in the computation.</p>
</div>
<div class="paragraph">
<p>You will consider a graph with relationships weighted by the number of times a pair of individuals have interacted.</p>
</div>
<div class="paragraph">
<p><strong>Note:</strong> You are casting the weight property from the graph as a float because that is what the algorithm expects as an input.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.create('got-wcc-weighted-interactions',
  'Person',
  {
    INTERACTS: {
      orientation: 'NATURAL',
      properties: {
        weight: {
          property: 'weight',
          defaultValue: 0.0,
          aggregation: 'SINGLE'
        }
      }
    }
  }
)<!--/code--></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.wcc.stream(
  'got-wcc-weighted-interactions',
  {
    relationshipWeightProperty:'weight',
    threshold:5.0
  }
)
YIELD nodeId, componentId
RETURN count(distinct componentId) as components<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>How does the number of identified communities change when you change the threshold?
What happens to their size?
What value produces the most communities?</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Weakly Connected Components: seeding</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>Now you can use the <code>wcc_partition</code> property to seed the algorithm with an initial community label.
This allows you to compute communities incrementally.</p>
</div>
<div class="paragraph">
<p>If you have not managed to create the property <code>wcc_partition</code>, execute the following query.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.wcc.write(
  'got-culture-interactions-cypher',
  {
    writeProperty: 'wcc_partition'
  }
)<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>Then, you can create a projected graph, called <code>got-wcc-interactions-seeded</code> and add the property to your <code>Person</code> nodes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.create(
  'got-wcc-interactions-seeded',
  {
    Person: {
      properties: 'wcc_partition'
    }
  },
  {
    INTERACTS: {
      orientation: 'UNDIRECTED',
      properties: 'weight'
    }
  }
)<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p><strong>Seeding</strong></p>
</div>
<div class="paragraph">
<p>For the Weakly Connected Components algorithm, this functionality is most useful when you want to add data to an existing graph.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->MATCH (p:Person)
WITH p.wcc_partition AS community, collect(p) AS members
WITH community, size(members) AS size, members[0] AS someGuy
    ORDER BY size DESC
    LIMIT 6
WITH collect(someGuy) AS someGuys
WITH someGuys, someGuys[0] AS first
MERGE (mats:Person {name: 'Mats'})
MERGE (mats)-[:INTERACTS]-&gt;(first)
WITH someGuys, someGuys[1] AS second
MERGE (martin:Person {name: 'Martin'})
MERGE (martin)-[:INTERACTS]-&gt;(second)
WITH someGuys, someGuys[2] AS third
MERGE (jonatan:Person {name: 'Jonatan'})
MERGE (jonatan)-[:INTERACTS]-&gt;(third)
WITH someGuys, someGuys[3] AS fourth
MERGE (max:Person {name: 'Max'})
MERGE (max)-[:INTERACTS]-&gt;(fourth)
WITH someGuys, someGuys[4] AS fifth
MERGE (soren:Person {name: 'Soren'})
MERGE (soren)-[:INTERACTS]-&gt;(fifth)
WITH someGuys, someGuys[5] AS sixth
MERGE (paul:Person {name: 'Paul'})
MERGE (paul)-[:INTERACTS]-&gt;(fourth)<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>Now let&#8217;s use the previously labeled <code>wcc_partition</code> as a seed, and assign communities to your new nodes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.wcc.stream(
  'got-wcc-interactions-seeded',
  {
    seedProperty: 'wcc_partition'
  }
)
YIELD nodeId, componentId
RETURN componentId, count(nodeId) AS size
ORDER BY size DESC<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>The number of communities is the same as before, but you have also added the properties to the new nodes.
On a small graph this is trivial, but on a large graph this saves a lot of computational time.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Weakly Connected Components: exercise</h3>
    <br/>
    <div>
      <div class="ulist">
<ul>
<li>
<p>Can you use a Cypher projection to create a graph that contains at least five communities with more than two members?</p>
</li>
<li>
<p>Can you use a Cypher projection with thresholding (you can use Cypher to add a new weight property if you want) to break the graph into multiple properties?
Does increasing your threshold create <em>more</em> or <em>fewer</em> partitions?</p>
</li>
<li>
<p>Using the previous exercise, write the partitions to the graph, and then use them as seeds for Union Find on the full graph, using <code>Person</code> and <code>INTERACTS</code>.
How many communities do you find?
What happened?</p>
</li>
</ul>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Weakly Connected Components: cleanup</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>To remove the nodes that have been created during the seeding exercise, run the following query:</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->MATCH (p:Person) WHERE p.name IN ['Mats', 'Martin', 'Jonatan', 'Max', 'Soren', 'Paul'] DETACH DELETE p<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>To clean up the in-memory graphs created during the exercises, you can run the following queries.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.drop('got-culture-interactions-cypher');<!--/code--></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.drop('got-wcc-weighted-interactions');<!--/code--></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.drop('got-wcc-interactions-seeded');<!--/code--></pre>
</div>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Louvain</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>The Louvain algorithm, like Label Propagation and Weakly Connected Components, is a community detection algorithm, designed to identify clusters in the graph. It differs from Label Propagation and Weakly Connected Components in how it finds communities:
It uses so called modularity, i.e. how densely connected communities are versus a random graph, to define the community structure. It&#8217;s also
a <em>hierarchical clustering</em> algorithm, so it can return communities at different scales, which can be useful for understanding how communities can combine at different levels.</p>
</div>
<div class="paragraph">
<p>The algorithm consists of the repeated application of two steps. The first step is a "greedy" assignment of nodes to communities,
favoring local optimizations of modularity. The second step is the definition of a new coarse-grained network, based on the
communities found in the first step.
During this step nodes of the same community are merged into a single node, inheriting all connected relationships.
These two steps are repeated until no further modularity-increasing reassignments of communities are possible. Because ties are broken
arbitrarily, you can get different results between different runs of the Louvain algorithm.</p>
</div>
<div class="paragraph">
<p>The main drawback to Louvain is that it is significantly slower that Label Propagation and Weakly Connected Components, and the results can be hard to interpret.
The algorithm is sensitive to the weighting scheme used on relationships. A good sign you need to tweak your schema or weighting is when you notice your results
include only a <em>single</em> giant community, or every node is in it&#8217;s own community of one.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Louvain: examples</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>We will compute the Louvain community structure of our pre-loaded graph.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.louvain.stream('got-interactions')
YIELD nodeId, communityId
RETURN gds.util.asNode(nodeId).name AS person, communityId
ORDER BY communityId DESC<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>The above query returns the name of the <code>Person</code> and the <code>community ID</code> they belongs to.
If we want to investigate how many communities there are, and how many members there are in each community we can change the RETURN statement:</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.louvain.stream('got-interactions')
YIELD nodeId, communityId
RETURN communityId, COUNT(DISTINCT nodeId) AS members
ORDER BY members DESC<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>We can see that there are 1382 communities - 11 with more than one member.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Louvain: weighting</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>The Louvain algorithm can also run on weighted graphs, taking the given relationship weights into concern when calculating the modularity.</p>
</div>
<div class="paragraph">
<p>Before we continue we need a graph that was created with the <code>weight</code> relationship property.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.create(
  'got-weighted-interactions',
  'Person',
  {
    INTERACTS: {
      orientation: 'UNDIRECTED',
      aggregation: 'NONE',
      properties: {
      	weight: {
          property: 'weight',
          aggregation: 'NONE',
          defaultValue: 0.0
        }
      }
    }
  }
)<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>If a relationship doesn&#8217;t have a <code>weight</code> property the number specified in <code>defaultValue</code> will be used as a fallback.</p>
</div>
<div class="paragraph">
<p>We can then use the 'weight' property on the INTERACTS relationship and see what happens:</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.louvain.stream(
  'got-weighted-interactions',
  {
    relationshipWeightProperty: 'weight'
  }
)
YIELD nodeId, communityId
RETURN communityId, COUNT(DISTINCT nodeId) AS members
ORDER BY members DESC<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>This gives us 1384 communities, 13 with more than one member.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Louvain: intermediate communities</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>One of the cool things about Louvain is that it is hierarchical clustering algorithm.
It identifies communities at multiple levels in the graph: first smaller communities, that then combine to form larger ones.</p>
</div>
<div class="paragraph">
<p>To retrieve the intermediate communities, you can simple set <code>includeIntermediateCommunities: true</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.louvain.stream(
  'got-interactions',
  {
    includeIntermediateCommunities: true
  }
)
YIELD nodeId, communityId, intermediateCommunityIds
RETURN communityId, COUNT(DISTINCT nodeId) AS members, intermediateCommunityIds<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>We can extract membership in different levels of communities and see how the composition changes:</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.louvain.stream(
  'got-interactions',
  {
    includeIntermediateCommunities: true
  }
)
YIELD nodeId, communityIds
RETURN count(distinct communityIds[0]), count(distinct communityIds[1])<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p><code>includeIntermediateCommunities: false</code> is the default value, in this case the <code>communityIds</code> field of the result is <code>null</code></p>
</div>
<div class="paragraph">
<p>Can you identify nodes that belong to different communities in the first level of hierarchy, but combine to the same community in the next level?</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Louvain: cleanup</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>To clean up the in-memory graph created during the Louvain exercise you can run the following query</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.drop('got-weighted-interactions');<!--/code--></pre>
</div>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Node Similarity</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>The Node Similarity algorithm is used to compute similarity scores for pairs of nodes in a graph.
The similarity between two nodes is based on the respective sets of neighbors.</p>
</div>
<div class="paragraph">
<p>To obtain a similarity measure between two sets, we use <em>Jaccard Similarity</em>.
More precisely the similarity between two nodes A and B is given by J = [#nodes neighboring A and B] / [#nodes neighboring A or B (or both)].
That is, the nodes are similar if most nodes that are neighbors to either node are in fact neighbors to both.</p>
</div>
<div class="paragraph">
<p>Typically, Node Similarity is used on a bipartite graph, for example containing People that have a <code>LIKES</code> relationship to Items.
Node Similarity can then be used to find the pairs of People that are the most similar in the sense that they mostly like the same items.</p>
</div>
<div class="paragraph">
<p>For more information see <a href="https://neo4j.com/docs/graph-algorithms/current/algorithms/node-similarity/" class="bare">https://neo4j.com/docs/graph-algorithms/current/algorithms/node-similarity/</a>.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Node Similarity: example graph</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>We will explore Node Similarity on a graph consisting of GOT characters and various entities that they relate to.
The task will be to find characters that are similar when comparing the books they appear or die in, as well as the houses and cultures they belong to.
This is a bipartite graph between <code>Person</code> on one side and <code>Book</code>, <code>House</code> and <code>Culture</code> on the other side.</p>
</div>
<div class="paragraph">
<p>We create the graph like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.graph.create('got-character-related-entities', ['Person', 'Book', 'House', 'Culture'], '*')<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>This graph creation uses projection with multiple node labels.
We load all types of relationships with <code>*</code>.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Node Similarity: simple run</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>We will now run Node Similarity with default settings and extract the top 10 most similar pairs of characters.
The algorithm will compute similarities only for <code>Person</code> nodes as these are the only nodes with outgoing edges.
To get more interesting results, we consider only characters with at least 20 related entities.
The property <code>degreeCutoff</code> accomplishes precisely that.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.nodeSimilarity.stream(
  'got-character-related-entities',
  {
    degreeCutoff: 20
  }
)
YIELD node1, node2, similarity
RETURN gds.util.asNode(node1).name as character1, gds.util.asNode(node2).name as character2, similarity
ORDER BY similarity DESC
LIMIT 10<!--/code--></pre>
</div>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Node Similarity: similarity cutoff</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>In most real-world graphs, the number of pairs of nodes to compare is huge and most pairs are not similar, it is useful to be able to limit the output.
There are several ways to deal with this.
We will begin by setting a threshold for a minimum similarity we are interested in by specifying the <code>similarityCutoff</code> property.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.nodeSimilarity.stream(
  'got-character-related-entities',
  {
    degreeCutoff: 20,
    similarityCutoff: 0.45
  }
)
YIELD node1, node2, similarity
RETURN gds.util.asNode(node1).name as character1, gds.util.asNode(node2).name as character2, similarity
ORDER BY similarity DESC<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>Note that we no longer need to use the LIMIT clause thanks to the similarity threshold.</p>
</div>
<div class="paragraph">
<p>By default the similarity cutoff is a very small number, effectively filtering out pairs that have zero similarity.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Node Similarity: topN</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>We can also limit the number of similarities returned by using the <code>topN</code> config option.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.nodeSimilarity.stream(
  'got-character-related-entities',
  {
    degreeCutoff: 20,
    topN: 10
  }
)
YIELD node1, node2, similarity
RETURN gds.util.asNode(node1).name as character1, gds.util.asNode(node2).name as character2, similarity
ORDER BY similarity DESC<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>This algorithm specific way of limiting is more memory efficient than constructing the entire stream and using the LIMIT clause afterwards.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Node Similarity: topK</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>Another way to limit the results is the <code>topK</code> config option.
This makes the algorithm output the <code>K</code> most similar characters for each character.
Let&#8217;s set this value to 1, since then we expect Loras Tyrell to have only one similar neighbor instead of two.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.nodeSimilarity.stream(
  'got-character-related-entities',
  {
    degreeCutoff: 20,
    topN: 10,
    topK: 1
  }
)
YIELD node1, node2, similarity
RETURN gds.util.asNode(node1).name as character1, gds.util.asNode(node2).name as character2, similarity
ORDER BY similarity DESC<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>Did you notice anything surprising?
Loras Tyrell still appeared twice as character2!
The algorithm will only return the most similar character to Loras when considering his neighbors.
The explanation is that when considering other characters, it is possible that multiple ones have Loras as their most similar neighbor.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Node Similarity: bottomN and bottomK</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>Similarily to <code>topN</code> and <code>topK</code>, the <code>bottomN</code> and <code>bottomK</code> config options limit the results but return the least similar pairs.
We will not include an example, but the interested reader is encouraged to try it out!</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>Node Similarity: writing</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>We end this chapter with an example that shows how to write similarity scores back to Neo4j.
The output of the algorithm can be written as weighted relationships.
The weight property is set to the computed similarity of the nodes that the relationship concerns.
The name of the property written to is specified by the config option <code>writeProperty</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre mode="cypher"  class="highlight pre-scrollable programlisting cm-s-neo code runnable standalone-example ng-binding" data-lang="cypher" lang="cypher"><!--code class="cypher language-cypher"-->CALL gds.nodeSimilarity.write(
  'got-character-related-entities',
  {
    degreeCutoff: 20,
    topN: 10,
    topK: 1,
    writeRelationshipType: 'SIMILARITY',
    writeProperty: 'character_similarity'
  }
)<!--/code--></pre>
</div>
</div>
<div class="paragraph">
<p>We can see that this wrote 10 relationships which is due to the topN value.</p>
</div>
	</div>
  </div>
</slide>



<slide class="row-fluid">
  <div class="col-sm-12">
    <h3>The end</h3>
    <br/>
    <div>
      <div class="paragraph">
<p>Thank you for learning Graph Algorithms!</p>
</div>
	</div>
  </div>
</slide>
  </carousel>
</article>